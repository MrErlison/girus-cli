apiVersion: v1
kind: ConfigMap
metadata:
  name: linux-shell-script-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: linux-shell-script-es
    title: "Introdução ao Shell Script Bash"
    description: "crea seus primeiros scripts Bash, aprendendo sobre variáveis, loops e condicionais neste laboratorio detalhado e guiado. Ideal para iniciantes que querem dominar os conceitos básicos de automação no Linux."
    duration: 25m
    image: "linuxtips/girus-devops:0.1"
    tasks:
      - name: "creando e Executando un Script Simples"
        description: "aprende a estrutura básica de un script Bash, como crear, salvar e executar scripts, e entenda os componentes fundamentais que todo script debe ter."
        steps:
          - "O shell script é uma poderosa ferramenta para automatizar tarefas no Linux. vamos crear nosso primeiro script seguindo estes passos:"
          - "Primeiro, crea un archivo chamado 'meu_script.sh':"
          - "`touch meu_script.sh`"
          - "Agora, vamos usar o editor nano para escrever o script (é mais amigável para iniciantes):"
          - "`nano meu_script.sh`"
          - "No editor, digite o seguinte conteúdo (linha por linha):"
          - |
            ```bash
            #!/bin/bash
            # Este é un comentário
            # Os comentários não são executados e servem para documentar o código

            # comando para exibir uma mensagem na tela
            echo "Olá, Girus!"
            
            # comando com substituição de comando $(comando)
            echo "O directorio atual é: $(pwd)"
            
            # Exibindo a data e hora atual
            echo "Data e hora atual: $(date)"
            ```
          - "Depois de digitar o conteúdo, salve o archivo pressionando Ctrl+O, depois Enter, e saia do editor com Ctrl+X."
          - "Se preferir usar outro editor como vim ou não quiser usar un editor interativo, usted também pode crear o archivo com o comando cat:"
          - |
            cat > meu_script.sh << 'EOF'
            #!/bin/bash
            # Este é un comentário
            # Os comentários não são executados e servem para documentar o código

            # comando para exibir uma mensagem na tela
            echo "Olá, Girus!"

            # comando com substituição de comando $(comando)
            echo "O directorio atual é: $(pwd)"

            # Exibindo a data e hora atual
            echo "Data e hora atual: $(date)"
            EOF
          - "Agora, vamos verificar o conteúdo do script para confirmar que foi criado corretamente:"
          - "`cat meu_script.sh`"
          - "Por padrão, os archivos novos não têm permissão de execução. vamos tornar o script executável:"
          - "`chmod +x meu_script.sh`"
          - "Podemos verificar as permissões do archivo com o comando:"
          - "`ls -l meu_script.sh`"
          - "usted debe ver algo como '-rwxr-xr-x', onde os 'x' indicam permissão de execução."
          - "Agora execute o script:"
          - "`./meu_script.sh`"
          - "O './' antes do nome do archivo indica que queremos executar o archivo no directorio atual."
          - "usted debe ver a mensagem 'Olá, Girus!', seguida do directorio atual e da data/hora."
        tips:
          - type: "info"
            title: "Shebang (#! /bin/bash)"
            content: "A primeira linha `#!/bin/bash` é chamada de 'shebang' e indica ao sistema qual interpretador usar para executar o script. Embora opcional, é uma boa prática sempre incluí-la para garantir que o script seja interpretado pelo bash, mesmo se executado em diferentes ambientes."
          - type: "tip"
            title: "Permissão de Execução"
            content: "archivos de script precisam da permissão de execução ('x') para serem rodados diretamente com `./nome_script.sh`. Use `chmod +x` para adicioná-la. Alternativamente, usted pode executar o script com `bash meu_script.sh`, o que não requer permissão de execução."
          - type: "info"
            title: "Substituição de comando"
            content: "A sintaxe $(comando) é chamada de 'substituição de comando' e permite incluir a saída de un comando dentro de outro comando ou string. Uma sintaxe mais antiga é usar crases: `comando`."
        validation:
          - command: "./meu_script.sh | grep 'Olá, Girus!'"
            expectedOutput: "Olá, Girus!"
            errorMessage: "O script não produziu a saída esperada 'Olá, Girus!'. verifique se usted criou o archivo corretamente e se ele tem permissão de execução."

      - name: "Usando Variáveis e Argumentos"
        description: "aprende a declarar e usar variáveis em scripts Bash, além de acessar e processar argumentos de linha de comando passados para o script."
        steps:
          - "As variáveis permitem armazenar e reutilizar valores no script. Os argumentos são valores passados ao script quando ele é executado."
          - "vamos modificar nosso script 'meu_script.sh' para usar variáveis e argumentos. Abra o archivo com o editor:"
          - "`nano meu_script.sh`"
          - "Substitua o conteúdo existente pelo seguinte:"
          - |
            ```bash
            #!/bin/bash
            
            # Declaração de variáveis (sem espaços ao redor do sinal de igual)
            NOME="Aluno Girus"
            CURSO="Shell Script"
            DATA_ATUAL=$(date +"%d/%m/%Y")
            
            # Usando as variáveis
            echo "Olá, $NOME!"
            echo "Bem-vindo ao curso de $CURSO"
            echo "Hoje é: $DATA_ATUAL"
            
            # Trabalhando com argumentos de linha de comando
            echo "----------------------------"
            echo "Informações sobre argumentos:"
            echo "----------------------------"
            echo "O script foi chamado com $# argumento(s)."
            echo "O nome do script é: $0"
            echo "O primeiro argumento foi: $1"
            echo "O segundo argumento foi: $2"
            echo "Todos os argumentos: $@"
            
            # Capturando o valor de un argumento em uma variável
            ARGUMENTO1=$1
            echo "----------------------------"
            echo "O valor de ARGUMENTO1 é: $ARGUMENTO1"
            ```
          - "Salve as alterações (Ctrl+O, Enter, Ctrl+X)."
          - "vamos executar o script sem argumentos primeiro:"
          - "`./meu_script.sh`"
          - "Observe que as variáveis $1, $2, etc. estarão vazias, pois não passamos argumentos."
          - "Agora, vamos executar o script com argumentos:"
          - "`./meu_script.sh 'Aprendendo Bash' 42`"
          - "Observe como os argumentos são acessados: $1 contém 'Aprendendo Bash' e $2 contém '42'."
          - "vamos experimentar com mais argumentos:"
          - "`./meu_script.sh argumento1 'argumento com espaços' 123 \"outro argumento\"`"
          - "Note que argumentos com espaços debem estar entre aspas para serem tratados como un único argumento."
        tips:
          - type: "info"
            title: "Variáveis no Bash"
            content: "No Bash, as variáveis são não-tipadas (o tipo é inferido automaticamente). Não use espaços ao redor do sinal de igual (**NOME='valor'** é correto, **NOME = 'valor'** causará erro). Para acessar o valor de uma variável, use o prefixo $ (ex: **$NOME**)."
          - type: "info"
            title: "Variáveis Especiais"
            content: "O Bash possui várias variáveis especiais úteis para scripts - **$#** (número de argumentos), **$0** (nome do script), **$1**, **$2**... (argumentos posicionais), **$@** (todos argumentos como palavras separadas), **$*** (todos argumentos como uma única palavra), **$?** (status de saída do último comando, 0 significa sucesso)."
          - type: "warning"
            title: "Usando aspas com variáveis"
            content: "É uma boa prática usar variáveis entre aspas duplas quando o valor pode conter espaços ou caracteres especiais - **echo \"$NOME\"** em vez de **echo $NOME**. Isso evita compuertomentos inesperados."
          - type: "tip"
            title: "Capturando Saída de comandos"
            content: "Além de **$(comando)**, usted pode usar a notação mais antiga - **RESULTADO=\\`comando\\`**"
        validation:
          - command: "./meu_script.sh teste | grep 'O primeiro argumento foi: teste'"
            expectedOutput: "O primeiro argumento foi: teste"
            errorMessage: "O script não parece estar processando o primeiro argumento corretamente. verifique o código e confirme se usted está passando o argumento 'teste'."

      - name: "Estruturas de Controle: Loop For e If"
        description: "aprende a usar estruturas de controle como loops 'for' para iteração e condicionais 'if' para tomada de decisões, permitindo crear scripts mais poderosos e dinâmicos."
        steps:
          - "As estruturas de controle permitem que os scripts tomem decisões e realizem repetições, tornando-os muito mais poderosos."
          - "vamos modificar 'meu_script.sh' para incluir loops e condicionais. Abra o archivo:"
          - "`nano meu_script.sh`"
          - "Substitua todo o conteúdo pelo seguinte:"
          - |
            ```bash
            #!/bin/bash
            
            echo "====================="
            echo "   LOOPS EM BASH    "
            echo "====================="
            
            # Loop básico com for
            echo "Loop for com lista de números:"
            for i in 1 2 3 4 5; do
              echo "  Número: $i"
            done
            
            # Loop for com sequência usando a sintaxe {início..fim}
            echo "Loop for com sequência {1..5}:"
            for i in {1..5}; do
              echo "  Valor: $i"
            done
            
            # Loop for com strings
            echo "Loop for com lista de palavras:"
            for palavra in Linux "Shell Script" Automação DevOps; do
              echo "  Palavra: $palavra"
            done
            
            # Loop for com substituição de comando
            echo "Loop for com archivos no directorio atual:"
            for archivo in $(ls); do
              echo "  archivo: $archivo"
            done
            
            echo "====================="
            echo " CONDICIONAIS EM BASH "
            echo "====================="
            
            # Verificando se foi fornecido un argumento
            if [ $# -eq 0 ]; then
              echo "Nenhun argumento foi fornecido."
              echo "Execute o script com: ./meu_script.sh ARGUMENTO"
            else
              echo "Foram fornecidos $# argumentos."
              
              # Verificando o valor do primeiro argumento
              if [ "$1" == "teste" ]; then
                echo "O primeiro argumento é 'teste'!"
              elif [ "$1" == "help" ]; then
                echo "AJUDA: Este script demonstra loops e condicionais em Bash."
              else
                echo "O primeiro argumento é: '$1' (não é 'teste' nem 'help')."
              fi
              
              # Verificando se o argumento é un número
              if [[ "$1" =~ ^[0-9]+$ ]]; then
                echo "'$1' é un número."
                
                # Verificando se o número é par ou ímpar
                if (( $1 % 2 == 0 )); then
                  echo "'$1' é un número par."
                else
                  echo "'$1' é un número ímpar."
                fi
              else
                echo "'$1' não é un número."
              fi
            fi
            ```
          - "Salve as alterações (Ctrl+O, Enter, Ctrl+X)."
          - "vamos executar o script com diferentes argumentos para ver como ele se compuerto:"
          - "Sem argumento:"
          - "`./meu_script.sh`"
          - "Com o argumento 'teste':"
          - "`./meu_script.sh teste`"
          - "Com o argumento 'help':"
          - "`./meu_script.sh help`"
          - "Com un número par:"
          - "`./meu_script.sh 42`"
          - "Com un número ímpar:"
          - "`./meu_script.sh 33`"
          - "Experimente também com outros valores para ver como o script se compuerto!"
        tips:
          - type: "info"
            title: "Estrutura do Loop For"
            content: "O loop for no Bash segue a sintaxe: 'for variável in lista; do comandos; done'. A lista pode ser números, strings, padrões de archivos, saídas de comandos ou sequências como {1..10}."
          - type: "info"
            title: "Sintaxe do If"
            content: "O if no Bash segue a estrutura: 'if [ condição ]; then comandos; elif [ outra_condição ]; then comandos; else comandos; fi'. Note o 'fi' (if invertido) que fecha o bloco."
          - type: "warning"
            title: "Testes com [ ] vs [[ ]]"
            content: "O Bash oferece duas formas de testes: [ ] (compatível com sh) e [[ ]] (específico do bash, mais poderoso). Com [[ ]] usted pode usar operadores como =~, &&, || sem escapar, e evita erros com variáveis vazias."
          - type: "tip"
            title: "Operadores de Comparação"
            content: "Numéricos: -eq (igual), -ne (diferente), -gt (maior), -lt (menor), -ge (maior/igual), -le (menor/igual). Strings: == (igual), != (diferente), -z (vazia), -n (não vazia). archivos: -f (existe/regular), -d (directorio), -r (legível)."
          - type: "info"
            title: "Expressões Aritméticas"
            content: "Use (( )) para expressões aritméticas, como: if (( $nun % 2 == 0 )); then echo 'Par'; fi. Dentro de (( )), usted não precisa do $ antes das variáveis."
        validation:
          - command: "./meu_script.sh teste | grep \"O primeiro argumento é 'teste'!\""
            expectedOutput: "O primeiro argumento é 'teste'!"
            errorMessage: "A estrutura condicional 'if' não funcionou como esperado para o argumento 'teste'. verifique seu código."
          - command: "./meu_script.sh 42 | grep \"'42' é un número par.\""
            expectedOutput: "'42' é un número par."
            errorMessage: "O script não identificou corretamente '42' como un número par. verifique a lógica condicional."

      - name: "Funções e Manipulação de archivos"
        description: "aprende a crear e usar funções para organizar seu código e a realizar operações básicas de manipulação de archivos nos seus scripts."
        steps:
          - "As funções permitem organizar e reutilizar código. vamos crear un script que usa funções e manipula archivos."
          - "crea un novo archivo chamado 'funcoes_archivos.sh':"
          - "`nano funcoes_archivos.sh`"
          - "Digite o seguinte conteúdo:"
          - |
            ```bash
            #!/bin/bash
            
            # Função para exibir uma linha de separação
            linha_separadora() {
              local caractere=${1:-"-"}  # Parâmetro com valor padrão
              local tamanho=${2:-50}     # Segundo parâmetro com valor padrão
              
              # Repete o caractere pelo tamanho especificado
              printf "%${tamanho}s\n" | tr " " "$caractere"
            }
            
            # Função para verificar se un archivo existe
            verificar_archivo() {
              local archivo="$1"
              
              if [ -f "$archivo" ]; then
                echo "O archivo '$archivo' existe."
                return 0  # Sucesso
              else
                echo "O archivo '$archivo' não existe."
                return 1  # Falha
              fi
            }
            
            # Função para obter informações sobre un archivo
            info_archivo() {
              local archivo="$1"
              
              # Verifica se o archivo existe usando a função anterior
              if ! verificar_archivo "$archivo"; then
                return 1
              fi
              
              linha_separadora "=" 60
              echo "Informações do archivo: $archivo"
              linha_separadora "-" 60
              
              echo "Tamanho: $(du -h "$archivo" | cut -f1)"
              echo "Permissões: $(ls -l "$archivo" | awk '{print $1}')"
              echo "Proprietário: $(ls -l "$archivo" | awk '{print $3}')"
              echo "Última modificação: $(date -r "$archivo")"
              
              # Detecta o tipo de archivo
              if file "$archivo" | grep -q "text"; then
                echo "Tipo: archivo de texto"
                echo "Número de linhas: $(wc -l < "$archivo")"
              else
                echo "Tipo: archivo binário ou não-texto"
              fi
              
              linha_separadora "=" 60
            }
            
            # Função para crear un archivo de texto
            crear_archivo_texto() {
              local archivo="$1"
              local linhas=${2:-5}  # Número de linhas (padrão: 5)
              
              echo "creando archivo '$archivo' com $linhas linhas..."
              
              # Cria o archivo com o número especificado de linhas
              for ((i=1; i<=linhas; i++)); do
                echo "Esta é a linha $i do archivo gerado automaticamente." >> "$archivo"
              done
              
              echo "archivo criado com sucesso!"
              
              # Exibe informações sobre o archivo criado
              info_archivo "$archivo"
            }
            
            # Programa principal
            linha_separadora "#" 60
            echo "           MANIPULAÇÃO DE archivoS EM BASH            "
            linha_separadora "#" 60
            
            # Verifica se foi fornecido un nome de archivo
            if [ $# -eq 0 ]; then
              echo "Uso: $0 <nome_archivo> [número_de_linhas]"
              exit 1
            fi
            
            archivo="$1"
            linhas=${2:-10}  # Usa 10 como padrão se não for fornecido
            
            # Verifica se o archivo já existe
            if [ -f "$archivo" ]; then
              echo "O archivo '$archivo' já existe."
              echo "O que deseja fazer?"
              echo "1. Sobrescrever"
              echo "2. Mostrar informações"
              echo "3. Sair"
              
              read -p "Escolha uma opção (1-3): " opcao
              
              case $opcao in
                1)
                  crear_archivo_texto "$archivo" "$linhas"
                  ;;
                2)
                  info_archivo "$archivo"
                  ;;
                3)
                  echo "Operação cancelada."
                  exit 0
                  ;;
                *)
                  echo "Opção inválida!"
                  exit 1
                  ;;
              esac
            else
              crear_archivo_texto "$archivo" "$linhas"
            fi
            ```
          - "Salve o archivo (Ctrl+O, Enter, Ctrl+X)."
          - "Torne o script executável:"
          - "`chmod +x funcoes_archivos.sh`"
          - "Agora execute o script, fornecendo un nome de archivo como argumento:"
          - "`./funcoes_archivos.sh teste.txt 15`"
          - "Isso creará un archivo 'teste.txt' com 15 linhas de texto."
          - "usted pode executar o script novamente com o mesmo archivo para ver as opções:"
          - "`./funcoes_archivos.sh teste.txt`"
          - "Experimente as diferentes opções (1, 2 ou 3)."
          - "verifique o conteúdo do archivo criado:"
          - "`cat teste.txt`"
        tips:
          - type: "info"
            title: "Definição de Funções"
            content: "As funções no Bash podem ser definidas como: nome_funcao() { comandos; } ou function nome_funcao { comandos; }. Elas são chamadas usando apenas o nome: nome_funcao arg1 arg2."
          - type: "tip"
            title: "Parâmetros em Funções"
            content: "Dentro de uma função, $1, $2, etc. referem-se aos parâmetros da função, não aos argumentos do script. Use 'local' para declarar variáveis locais à função (não disponíveis fora dela)."
          - type: "info"
            title: "Valor de Retorno"
            content: "Funções Bash retornam un código de status (0-255) usando 'return'. Use 0 para sucesso e valores não-zero para erro. Para retornar strings ou valores, use 'echo' e capture a saída."
          - type: "warning"
            title: "Manipulação de archivos"
            content: "Sempre verifique se un archivo existe antes de manipulá-lo e use aspas ao redor de nomes de archivos para evitar problemas com espaços e caracteres especiais."
        validation:
          - command: "./funcoes_archivos.sh archivo_teste.txt 3 && cat archivo_teste.txt | wc -l"
            expectedOutput: "3"
            errorMessage: "O script não criou o archivo com o número correto de linhas."
          - command: "grep -q 'linha 2' archivo_teste.txt && echo 'success' || echo 'error'"
            expectedOutput: "success"
            errorMessage: "O conteúdo do archivo não parece estar correto."
