apiVersion: v1
kind: ConfigMap
metadata:
  name: kubernetes-servicos-redes-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: kubernetes-servicos-redes-es
    title: "servicios e Redes no Kubernetes"
    description: "aprende como expor aplicações executando em Pods e implementar a comunicação entre os componentes da sua aplicación usando os tipos de servicios do Kubernetes. Este laboratorio guiado explorará os conceitos fundamentais de redes no Kubernetes e como eles possibilitam a comunicação interna e externa às suas aplicações."
    duration: 30m
    image: "linuxtips/girus-kind-single-node:0.1"
    tasks:
      - name: "creando un Namespace Isolado"
        description: "Configure un namespace para isolar os recursos criados durante este laboratorio, compreendendo como os namespaces proporcionam isolamento lógico no Kubernetes."
        steps:
          - "No Kubernetes, **namespaces** fornecem uma forma de segmentar un cluster em ambientes virtuais isolados. Eles são fundamentais para organizar recursos em equipes grandes, separar ambientes (dev, teste, produção) ou isolar projetos."
          - "vamos crear un namespace dedicado para este laboratorio usando o comando `kubectl create namespace`:"
          - "`kubectl create namespace servicos-lab`"
          - "Este comando instrui a API do Kubernetes a crear un novo namespace chamado 'servicos-lab'. O namespace atua como un escopo virtual dentro do cluster, onde os recursos são nomeados de forma única."
          - "vamos verificar se o namespace foi criado corretamente listando todos os namespaces disponíveis:"
          - "`kubectl get namespaces`"
          - "usted debe ver o namespace 'servicos-lab' na lista, junto com os namespaces padrão como 'default', 'kube-system' e outros."
          - "Para facilitar nossos comandos, vamos configurar o namespace 'servicos-lab' como o namespace padrão para nuestra sessão atual:"
          - "`kubectl config set-context --current --namespace=servicos-lab`"
          - "Este comando altera o contexto atual do kubectl para usar 'servicos-lab' como namespace padrão. Isso significa que não precisaremos especificar `-n servicos-lab` em cada comando que executarmos."
        tips:
          - type: "info"
            title: "Namespaces no Kubernetes"
            content: "Os namespaces fornecem isolamento lógico, não físico. Recursos como nodes e PersistentVolumes não são isolados por namespace. Alguns recursos, como Nodes, são globais e não pertencem a nenhun namespace."
          - type: "tip"
            title: "Visualizar o Namespace Atual"
            content: "O comando `kubectl config view --minify | grep namespace:` mostra o namespace atual configurado no seu contexto. Se não houver namespace configurado, o comando não mostrará nada e o 'default' será usado."
        validation:
          - command: "kubectl get ns servicos-lab -o jsonpath='{.metadata.name}' 2>/dev/null || echo 'Namespace não encontrado'"
            expectedOutput: "servicos-lab"
            errorMessage: "O namespace 'servicos-lab' não foi criado corretamente. verifique o comando usado para crear o namespace."

      - name: "creando uma aplicación com Múltiplos Pods"
        description: "Implante uma aplicación web simples com frontend e backend para demonstrar como os servicios do Kubernetes facilitam a comunicação entre componentes da aplicación."
        steps:
          - "Antes de discutirmos servicios, precisamos crear alguns Pods para expor. Em aplicações reais, geralmente temos vários componentes que precisam se comunicar entre si, como frontend e backend."
          - "**Deployments** são recursos do Kubernetes que gerenciam a criação e actualización de Pods de forma declarativa. vamos crear un Deployment para o backend da nuestra aplicación:"
          - "`kubectl create deployment backend-app --image=nginxdemos/hello:0.3 --port=80 --replicas=2 -n servicos-lab`"
          - "Este comando cria un Deployment chamado 'backend-app' com 2 réplicas (2 Pods idênticos) usando a imagen 'nginxdemos/hello:0.3', que é uma imagen Nginx com uma página personalizada. A flag `--port=80` indica que o container expõe a puerto 80."
          - "vamos verificar se o Deployment foi criado e seus Pods estão em execução:"
          - "`kubectl get deployments -n servicos-lab`"
          - "usted debe ver o Deployment 'backend-app' com 2 réplicas disponíveis."
          - "Agora vamos ver os Pods criados pelo Deployment:"
          - "`kubectl get pods -n servicos-lab`"
          - "usted debe ver 2 Pods com nomes iniciando com 'backend-app-', cada un em estado 'Running'."
          - "Agora, vamos crear outro Deployment para representar o frontend da nuestra aplicación:"
          - "`kubectl create deployment frontend-app --image=nginx:alpine --port=80 -n servicos-lab`"
          - "Este comando cria un Deployment para o frontend usando a imagen 'nginx:alpine', que é uma versão leve do Nginx. Por padrão, o Kubernetes creará apenas 1 réplica quando não especificamos o número de réplicas."
          - "vamos verificar todos os Deployments no namespace:"
          - "`kubectl get deployments -n servicos-lab`"
          - "Agora usted debe ver dois Deployments: 'backend-app' com 2 réplicas e 'frontend-app' com 1 réplica."
          - "Para demonstrar como os Pods recebem IPs internos no Kubernetes, vamos listar os Pods com seus IPs:"
          - "`kubectl get pods -o wide -n servicos-lab`"
          - "A flag `-o wide` mostra informações adicionais, incluindo os IPs dos Pods. Observe que cada Pod recebe un IP único dentro da rede do cluster. Estes IPs são efêmeros - quando un Pod é recriado, ele recebe un novo IP."
        tips:
          - type: "info"
            title: "Rede de Pods no Kubernetes"
            content: "O Kubernetes atribui a cada Pod un IP único dentro do cluster. Todos os containers dentro de un Pod compartilham o mesmo IP e espaço de puertos. A comunicação entre Pods é possível por padrão, mas o IP do Pod mudará se ele for recriado."
          - type: "warning"
            title: "Comunicação Direta entre Pods"
            content: "Embora seja possível se comunicar diretamente com un Pod usando seu IP, esta abordagem é desencorajada porque os IPs dos Pods são efêmeros. Em vez disso, use servicios para descoberta e comunicação estável."
          - type: "tip"
            title: "Escalando Deployments"
            content: "usted pode alterar o número de réplicas de un Deployment com `kubectl scale deployment <nome> --replicas=<número>`. O Kubernetes creará ou removerá Pods para atingir o número desejado."
        validation:
          - command: "kubectl get pods -n servicos-lab -l app=backend-app --no-headers | wc -l"
            expectedOutput: "2"
            errorMessage: "Não foram encontrados 2 Pods para o backend-app. verifique se o Deployment foi criado corretamente com 2 réplicas."
          - command: "kubectl get pods -n servicos-lab -l app=frontend-app --no-headers | wc -l"
            expectedOutput: "1"
            errorMessage: "Não foi encontrado 1 Pod para o frontend-app. verifique se o Deployment foi criado corretamente."

      - name: "creando un servicio ClusterIP"
        description: "crea un servicio do tipo ClusterIP para expor o backend internamente no cluster, entendendo como os servicios proporcionam descoberta de servicio estável e balanceamento de carga."
        steps:
          - "Agora que temos nossos Pods em execução, precisamos de uma forma de acessá-los de maneira confiável. Como mencionado, os IPs dos Pods são efêmeros e não debem ser usados diretamente."
          - "Os **servicios** no Kubernetes proporcionam uma abstração que define un conjunto lógico de Pods e uma política para acessá-los. Eles permitem a descoberta de servicio e o balanceamento de carga entre Pods."
          - "O tipo mais básico de servicio é o **ClusterIP**, que expõe o servicio em un IP interno ao cluster. Este tipo é ideal para comunicação interna entre componentes da aplicación."
          - "vamos crear un servicio ClusterIP para o backend:"
          - "`kubectl expose deployment backend-app --name=backend-service --port=80 --target-port=80 --type=ClusterIP -n servicos-lab`"
          - "Este comando cria un servicio chamado 'backend-service' que expõe o Deployment 'backend-app' na puerto 80. vamos entender cada parâmetro:"
          - "- `--name=backend-service`: Define o nome do servicio"
          - "- `--port=80`: A puerto em que o servicio será exposto dentro do cluster"
          - "- `--target-port=80`: A puerto do Pod alvo para a qual o tráfego será redirecionado"
          - "- `--type=ClusterIP`: O tipo de servicio (ClusterIP é o padrão, por isso é opcional)"
          - "vamos verificar o servicio criado:"
          - "`kubectl get services -n servicos-lab`"
          - "usted verá o servicio 'backend-service' com un IP interno (ClusterIP) atribuído. Este IP é estático durante o ciclo de vida do servicio."
          - "Podemos obter mais detalhes sobre o servicio com o comando 'describe':"
          - "`kubectl describe service backend-service -n servicos-lab`"
          - "Observe que o servicio tem un conjunto de 'Endpoints' que são os IPs dos Pods individuais de backend. O Kubernetes mantém esta lista atualizada automaticamente à medida que Pods são criados ou removidos."
          - "Agora, vamos testar o acesso ao backend a partir de outro Pod. vamos usar o Pod do frontend para enviar uma requisição HTTP ao backend:"
          - "`kubectl exec -it $(kubectl get pod -l app=frontend-app -o jsonpath='{.items[0].metadata.name}' -n servicos-lab) -n servicos-lab -- curl -s backend-service`"
          - "Este comando executa 'curl' dentro do Pod frontend para acessar o 'backend-service'. Observe que usamos o nome do servicio como hostname, não seu IP. O Kubernetes configura DNS interno automaticamente para resolver nomes de servicios."
          - "O resultado mostrará a página HTML retornada pelo backend. O Kubernetes balanceou a requisição para un dos Pods do backend."
        tips:
          - type: "info"
            title: "Tipos de servicios"
            content: "O Kubernetes oferece vários tipos de servicios: ClusterIP (padrão, apenas interno), NodePort (expõe em puerto do Node), LoadBalancer (usa balanceador de carga externo) e ExternalName (redirecionamento DNS)."
          - type: "tip"
            title: "DNS do Kubernetes"
            content: "O Kubernetes configura automaticamente nomes DNS para servicios. Dentro do mesmo namespace, Pods podem acessar un servicio simplesmente pelo nome. Entre namespaces, use 'nome-servico.namespace.svc.cluster.local'."
          - type: "info"
            title: "Seletores e Endpoints"
            content: "Os servicios usam seletores de labels para identificar quais Pods debem receber tráfego. Os Endpoints são uma lista de todos os IPs e puertos dos Pods que correspondem ao seletor do servicio."
        validation:
          - command: "kubectl get service backend-service -n servicos-lab -o jsonpath='{.spec.type}' 2>/dev/null || echo ''"
            expectedOutput: "ClusterIP"
            errorMessage: "O servicio 'backend-service' do tipo ClusterIP não foi criado corretamente."
          - command: "kubectl get endpoints backend-service -n servicos-lab -o jsonpath='{.subsets[0].addresses}' 2>/dev/null | grep -c 'ip'"
            expectedOutput: "2"
            errorMessage: "O servicio 'backend-service' não está associado a 2 Pods backend. verifique se o seletor do servicio corresponde às labels dos Pods."

      - name: "creando un servicio NodePort"
        description: "Exponha o frontend para acesso externo usando un servicio NodePort, entendendo como este tipo de servicio permite o acesso a aplicações de fora do cluster."
        steps:
          - "Até agora, nosso 'backend-service' só pode ser acessado de dentro do cluster. Para expor servicios para acesso externo, o Kubernetes oferece outros tipos de servicios."
          - "O **NodePort** é un tipo de servicio que expõe o servicio em uma puerto estática em cada nó do cluster. Esta puerto é acessível externamente através do IP do nó."
          - "vamos crear un servicio NodePort para o frontend:"
          - "`kubectl expose deployment frontend-app --name=frontend-service --port=80 --target-port=80 --type=NodePort -n servicos-lab`"
          - "Este comando cria un servicio chamado 'frontend-service' do tipo NodePort que expõe o Deployment 'frontend-app'. O Kubernetes atribuirá automaticamente uma puerto aleatória na faixa 30000-32767."
          - "vamos verificar o servicio criado:"
          - "`kubectl get services -n servicos-lab`"
          - "usted verá o servicio 'frontend-service' com un ClusterIP atribuído e un campo 'PORT(S)' mostrando algo como '80:3xxxx/TCP', onde 3xxxx é a puerto NodePort atribuída."
          - "vamos capturar essa puerto NodePort para uso posterior:"
          - "`NODEPORT=$(kubectl get service frontend-service -n servicos-lab -o jsonpath='{.spec.ports[0].nodePort}')`"
          - "Agora podemos acessar o frontend através do IP do nó (que, em nosso ambiente Kind, é acessível via localhost) e a puerto NodePort:"
          - "`curl localhost:$NODEPORT`"
          - "usted debe ver a página HTML retornada pelo frontend (Nginx). Em un cluster real, usted poderia acessar este servicio através do IP de qualquer nó e a mesma puerto NodePort."
          - "Para demonstrar a comunicação entre servicios, vamos modificar o frontend para atuar como un proxy reverso para o backend. vamos crear un ConfigMap com uma configuração Nginx que encaminha requisições para '/api' para o backend:"
          - "`kubectl create configmap nginx-config --from-literal=nginx.conf='events {} http { server { listen 80; location / { root /usr/share/nginx/html; } location /api { proxy_pass http://backend-service; } } }' -n servicos-lab`"
          - "Agora, vamos actualizar o Deployment do frontend para usar esta configuração:"
          - "`kubectl set volumes deployment/frontend-app --add --name=config --mount-path=/etc/nginx/nginx.conf --sub-path=nginx.conf --configmap-name=nginx-config -n servicos-lab`"
          - "Este comando adiciona un volume ao Deployment 'frontend-app' que monta o ConfigMap 'nginx-config' no caminho '/etc/nginx/nginx.conf'. O Nginx lerá esta configuração e encaminhará requisições para '/api' para o 'backend-service'."
          - "vamos aguardar o Pod frontend ser recriado com a nova configuração:"
          - "`kubectl rollout status deployment/frontend-app -n servicos-lab`"
          - "Agora podemos testar o servicio. Quando acessamos '/api', o frontend debe encaminhar a requisição para o backend:"
          - "`curl localhost:$NODEPORT/api`"
          - "usted debe ver a resposta do backend, demonstrando que o frontend está encaminhando requisições para o backend usando o servicio interno 'backend-service'."
        tips:
          - type: "warning"
            title: "Limitações do NodePort"
            content: "NodePort não é geralmente recomendado para produção pois: 1) Usa puertos não-padrão, 2) Expõe puertos em todos os nós, mesmo que não estejam rodando o servicio, 3) Requer administración de IPs de nós, que podem mudar."
          - type: "info"
            title: "Arquitetura Comum"
            content: "un padrão comun no Kubernetes é ter servicios de frontend expostos externamente com NodePort ou LoadBalancer, enquanto servicios de backend usam ClusterIP para comunicação interna."
          - type: "tip"
            title: "Encadeamento de servicios"
            content: "Os servicios podem se comunicar entre si usando seus nomes DNS. Isso permite crear arquiteturas em camadas onde cada componente se concentra em sua função específica."
        validation:
          - command: "kubectl get service frontend-service -n servicos-lab -o jsonpath='{.spec.type}' 2>/dev/null || echo ''"
            expectedOutput: "NodePort"
            errorMessage: "O servicio 'frontend-service' do tipo NodePort não foi criado corretamente."
          - command: "NODEPORT=$(kubectl get service frontend-service -n servicos-lab -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo ''); curl -s localhost:$NODEPORT/api | grep -i 'nginx' || echo 'fail'"
            expectedOutput: "nginx"
            errorMessage: "Não foi possível acessar o backend através do frontend. verifique a configuração do proxy reverso."

      - name: "Limpeza dos Recursos"
        description: "Remova todos os recursos criados durante o laboratorio, entendendo como o Kubernetes gerencia o ciclo de vida dos recursos."
        steps:
          - "Depois de explorar os conceitos de servicios e Redes no Kubernetes, vamos limpar todos os recursos criados para manter o cluster organizado."
          - "No Kubernetes, a exclusão de recursos pode ser feita de várias maneiras. Podemos excluir recursos individualmente ou excluir o namespace, que remove todos os recursos dentro dele."
          - "vamos listar todos os recursos criados neste laboratorio:"
          - "`kubectl get all -n servicos-lab`"
          - "O comando `kubectl get all` mostra a maioria dos recursos do Kubernetes, incluindo Pods, servicios, Deployments, etc., mas não todos (por ejemplo, não mostra ConfigMaps)."
          - "vamos comenzar excluindo os servicios:"
          - "`kubectl delete service frontend-service backend-service -n servicos-lab`"
          - "Este comando exclui os dois servicios que criamos. Observe que a exclusão de un servicio não afeta os Pods subjacentes - eles continuam em execução."
          - "Agora, vamos excluir os Deployments:"
          - "`kubectl delete deployment frontend-app backend-app -n servicos-lab`"
          - "Quando excluímos un Deployment, o Kubernetes exclui automaticamente todos os Pods gerenciados por ele. Isso demonstra o conceito de propriedade no Kubernetes - quando un recurso de 'pai' é excluído, seus 'filhos' também são excluídos."
          - "vamos verificar se os Pods foram removidos:"
          - "`kubectl get pods -n servicos-lab`"
          - "Não deberia haver mais Pods listados."
          - "Agora, vamos excluir o ConfigMap:"
          - "`kubectl delete configmap nginx-config -n servicos-lab`"
          - "Finalmente, vamos excluir o namespace, o que removeria todos os recursos restantes nele (caso tivéssemos esquecido algum):"
          - "`kubectl delete namespace servicos-lab`"
          - "Esta é uma forma eficiente de limpar todos os recursos de un projeto ou experimento de uma só vez. No entanto, tenha cuidado ao usar este método em ambientes compartilhados ou de produção."
          - "vamos verificar se o namespace foi removido:"
          - "`kubectl get namespace servicos-lab || echo 'Namespace removido com sucesso'`"
          - "usted debe ver a mensagem 'Namespace removido com sucesso', indicando que o namespace não existe mais."
        tips:
          - type: "warning"
            title: "Exclusão de Namespaces"
            content: "A exclusão de un namespace é uma operação destrutiva que não pode ser desfeita. Todos os recursos no namespace serão permanentemente removidos. Use com cautela em ambientes compartilhados ou de produção."
          - type: "info"
            title: "Cascata de Exclusão"
            content: "O Kubernetes usa o conceito de 'propriedade' para administrar a exclusão em cascata. Quando un recurso 'pai' (como un Deployment) é excluído, todos os recursos 'filhos' (como os Pods) também são excluídos automaticamente."
          - type: "tip"
            title: "Verificação Antes da Exclusão"
            content: "Antes de excluir recursos, especialmente em produção, use `kubectl get <recurso> -o yaml` ou `kubectl describe <recurso>` para verificar se está excluindo os recursos corretos."
        validation:
          - command: "kubectl get namespace servicos-lab 2>/dev/null || echo 'Namespace removido com sucesso'"
            expectedOutput: "Namespace removido com sucesso"
            errorMessage: "O namespace 'servicos-lab' não foi removido corretamente. verifique se usted executou 'kubectl delete namespace servicos-lab'."
